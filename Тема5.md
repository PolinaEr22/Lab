# Тема 5. Базовые коллекции: множества, списки
Отчет по Теме №5 выполнил(а):
- Еремеева Полина Алексеевна
- ИНО ЗБ ПОАС 22-1

| Задание | Сам_раб |
| ------ | ------ |
| Задание 1 |  + |
| Задание 2 | + |
| Задание 3 | + |
| Задание 4 | + |
| Задание 5 | + |

знак "+" - задание выполнено; знак "-" - задание не выполнено;

Работу проверили:
- к.э.н., доцент Панов М.А.

## Самостоятельная работа №1

## 1)	Ресторан на предприятии ведет учет посещений за неделю при помощи кода работника. У них есть список со всеми посещениями за неделю. Ваша задача почитать:
•	Сколько было выдано чеков
•	Сколько разных людей посетило ресторан
•	Какой работник посетил ресторан больше всех раз 


```python
cheque_codes = [8734, 2345, 8201, 6621, 9999, 1234, 5678, 8201, 8888, 4321, 3365, 
                1478, 9865, 5555, 7777, 9998, 1111, 2222, 3333, 4444, 5556, 6666, 
                5410, 7778, 8889, 4445, 1439, 9604, 8201, 3365, 7502, 3016, 4928, 
                5837, 8201, 2643, 5017, 9682, 8530, 3250, 7193, 9051, 4506, 1987, 
                3365, 5410, 7168, 7777, 9865, 5678, 8201, 4445, 3016, 4506, 4506]

# Считаем количество выданных чеков, это же длина списка
total_cheques = len(cheque_codes)

# Считаем количество уникальных кодов работников, используя множество (set)
unique_visitors = len(set(cheque_codes))

# Находим самого частого посетителя
# Для этого создаем словарь, где ключ - это код работника, а значение - количество его посещений
visitors_frequency = {}
for code in cheque_codes:
    if code in visitors_frequency:
        visitors_frequency[code] += 1
    else:
        visitors_frequency[code] = 1

# Находим код работника с максимальным количеством посещений
most_frequent_visitor = max(visitors_frequency, key=visitors_frequency.get)
most_frequency = visitors_frequency[most_frequent_visitor]

# Выводим результат
print(f"Общее количество выданных чеков: {total_cheques}")
print(f"Количество разных людей, посетивших ресторан: {unique_visitors}")
print(f"Работник с кодом {most_frequent_visitor} посетил ресторан наибольшее количество раз - {most_frequency} раз(а)")
```
### Результат.

![Меню](https://github.com/PolinaEr22/Lab/blob/Тема5/pic/1.png)

## Выводы

В данном коде выполняется анализ данных о посещениях ресторана работниками на основе предоставленного списка кодов работников, где каждый код представляет отдельный чек, выданный работнику. Этот код вычисляет три ключевых параметра:

1. Общее количество выданных чеков: Это подсчитывается как длина списка cheque_codes. Каждый элемент списка представляет собой один выданный чек, поэтому длина списка непосредственно отражает общее количество выданных чеков.

2. Количество разных людей, посетивших ресторан: Для этого используется множество (set). Преобразование списка кодов в множество автоматически удаляет все дубликаты, оставляя только уникальные значения. Таким образом, длина полученного множества показывает, сколько разных работников посетило ресторан.

3. Кто является самым частым посетителем ресторана: Для определения самого частого посетителя создается словарь visitors_frequency, где ключами служат коды работников, а значениями - количество их посещений. Проходя по списку чеков, код учитывает каждое посещение, инкрементируя значение в словаре для соответствующего ключа. Затем, чтобы найти самого частого посетителя, выбирается ключ с максимальным значением в этом словаре. max(visitors_frequency, key=visitors_frequency.get) возвращает код работника, который посещал ресторан наибольшее количество раз, а most_frequency показывает, сколько раз этот работник посетил ресторан.
   
## Самостоятельная работа №2

## На физкультуре студенты сдавали бег, у преподавателя физкультуры есть список всех результатов, ему нужно узнать
•	Три лучшие результата
•	Три худшие результата
•	Все результаты начиная с 10 


```python
running_results = [10.2, 14.8, 19.3, 22.7, 12.5, 33.1, 38.9, 21.6, 26.4, 17.1, 30.2, 35.7, 16.9,
                   27.8, 24.5, 16.3, 18.7, 31.9, 12.9, 37.4]

# Сначала сортируем список результатов по возрастанию
sorted_results = sorted(running_results)

# Три лучших результата
top_3 = sorted_results[:3]

# Три худших результата
bottom_3 = sorted_results[-3:]

# Все результаты начиная с 10 (поскольку список уже отсортирован, результаты >= 10 уже следуют по порядку)
results_from_10 = sorted_results[sorted_results.index(10.2):]

print("Три лучших результата:", top_3)
print("Три худших результата:", bottom_3)
print("Все результаты начиная с 10:", results_from_10)
```
### Результат.

![Меню](https://github.com/PolinaEr22/Lab/blob/Тема5/pic/2.png)

## Выводы

Данный код анализирует список результатов забега, представленный в виде времен в минутах, для каждого участника. Вот шаги, которые выполняются в коде, и их значение:

1. Сортировка результатов: Список running_results, содержащий временные результаты участников забега, сортируется по возрастанию с использованием функции sorted(). Это означает, что самые быстрые времена окажутся в начале списка, а самые медленные — в конце.

2. Определение трех лучших результатов: Выбираются первые три элемента отсортированного списка sorted_results. Эти элементы представляют собой три лучших времени забега.

3. Определение трех худших результатов: Выбираются последние три элемента отсортированного списка. Эти элементы представляют собой три самых медленных времени забега.

4. Получение всех результатов, начиная с определенного времени: В данном случае выбираются все результаты начиная с 10.2 минут (включительно) до конца списка. Ошибочное выражение "начиная с 10" исправлено на "начиная с 10.2", поскольку в списке нет значения ровно 10, и первое значение в отсортированном списке является 10.2.

## Самостоятельная работа №3

## Преподаватель по математике придумал странную задачку. У вас есть три списка с элементами, каждый элемент которых – длина стороны треугольника, ваша задача найти площади двух треугольников, составленные из максимальных и минимальных элементов полученных списков. Результатом выполнения задачи будет: листинг кода, и вывод в консоль, в котором будут указаны два этих значения.

```python
import math
# Заданные списки длин сторон
one = [12, 25, 3, 48, 71]
two = [5, 18, 40, 62, 98]
three = [4, 21, 37, 56, 84]

# Находим максимальные значения
max_a = max(one)
max_b = max(two)
max_c = max(three)

# Находим минимальные значения
min_a = min(one)
min_b = min(two)
min_c = min(three)

# Функция для расчета площади треугольника по формуле Герона
def heron_area(a, b, c):
    s = (a + b + c) / 2
    return math.sqrt(s * (s - a) * (s - b) * (s - c))

# Рассчитываем площади
max_area = heron_area(max_a, max_b, max_c)
min_area = heron_area(min_a, min_b, min_c)

print("Площадь треугольника, составленная из максимальных элементов:", max_area)
print("Площадь треугольника, составленная из минимальных элементов:", min_area
```
### Результат.

![Меню](https://github.com/PolinaEr22/Lab/blob/Тема5/pic/3.png)


## Выводы

Данный код выполняет следующие действия для расчета площадей двух треугольников, используя значения длин сторон, заданные в трех списках one, two, и three:

1. Определяет максимальные и минимальные значения длин сторон треугольников из каждого из предоставленных списков. Это делается с помощью функций max() и min() соответственно.

2. Использует формулу Герона для расчета площади треугольника. Формула Герона позволяет найти площадь треугольника, зная длины всех трех его сторон. Если a, b, и c - длины сторон треугольника, а s - полупериметр (s = (a + b + c) / 2), то площадь S может быть найдена по формуле: S = sqrt(s * (s - a) * (s - b) * (s - c)), где sqrt - квадратный корень.

3. Рассчитывает площадь двух треугольников:
   - Один треугольник с максимальными сторонами (max_a, max_b, max_c) из каждого списка.
   - Один треугольник с минимальными сторонами (min_a, min_b, min_c) из каждого списка.

4. Выводит площади этих треугольников на экран.


## Самостоятельная работа №4

## Никто не любит получать плохие оценки, поэтому Борис решил это исправить. Допустим, что все оценки студента за семестр хранятся в одном списке. Ваша задача удалить из этого списка все двойки, а все тройки заменить на четверки.

```python

def adjust_grades(grades):
    # Удаляем все двойки
    adjusted_grades = list(filter(lambda x: x != 2, grades))
    # Заменяем все тройки на четверки
    adjusted_grades = [4 if grade == 3 else grade for grade in adjusted_grades]
    return adjusted_grades

# Тестовые списки оценок
grades_lists = [
    [2, 3, 4, 5, 3, 4, 5, 2, 2, 5, 3, 4, 3, 5, 4],
    [4, 2, 3, 5, 3, 5, 4, 2, 2, 5, 4, 3, 5, 3, 4],
    [5, 4, 3, 3, 4, 3, 3, 5, 5, 3, 3, 3, 3, 4, 4]
]

# Обрабатываем каждый список оценок
for i, grades in enumerate(grades_lists, 1):
    adjusted_grades = adjust_grades(grades)
    print(f"Обновленный список оценок {i}: {adjusted_grades}")
```
### Результат.

![Меню](https://github.com/PolinaEr22/Lab/blob/Тема5/pic/4.png)


## Выводы

Данный код выполняет обработку списков оценок с целью улучшить общую успеваемость студентов, применяя две ключевые операции к каждому списку оценок:

1. Удаление всех двоек: Считая двойки (оценки ниже удовлетворительного уровня) неудовлетворительными, они удаляются из каждого списока оценок, так что они больше не влияют на общий анализ успеваемости.

2. Повышение всех троек до четверок: С целью улучшить оценки и мотивацию студентов, получивших тройки (оценки на грани удовлетворительного и хорошего уровней), все тройки заменяются на четверки (хорошие оценки).


## Самостоятельная работа №5

## Вам предоставлены списки натуральных чисел, из них необходимо сформировать множества. 

```python
def generate_set_from_list(input_list):
    # Считаем количество каждого элемента в списке
    element_count = {}
    for element in input_list:
        if element in element_count:
            element_count[element] += 1
        else:
            element_count[element] = 1
            
    # Создаем множество с уникальными элементами и строками для повторяющихся элементов
    result_set = set()
    for element, count in element_count.items():
        for i in range(1, count + 1):
            if i == 1:
                result_set.add(element)
            else:
                result_set.add(str(element) * i)
                
    return result_set

# Тестовые списки
list_1 = [1, 1, 3, 3, 1]
list_2 = [5, 5, 5, 5, 5, 5, 5]
list_3 = [2, 2, 1, 2, 2, 5, 6, 7, 1, 3, 2, 2]

# Генерируем и выводим множества
set_1 = generate_set_from_list(list_1)
set_2 = generate_set_from_list(list_2)
set_3 = generate_set_from_list(list_3)

print(set_1)
print(set_2)
print(set_3)
```
### Результат.

![Меню](https://github.com/PolinaEr22/Lab/blob/Тема5/pic/5.png)

## Выводы

реализует функцию generate_set_from_list(), которая преобразует список в множество с учетом особого правила для обработки повторяющихся элементов. Вот что делает каждая часть кода:

1. Подсчет количества каждого элемента в списке: Используется словать element_count, чтобы сохранить, сколько раз каждый элемент встречается во входном списке.

2. Формирование результата в виде множества: Создается множество result_set, в которое добавляются:
   - Уникальные элементы списка напрямую.
   - Для повторяющихся элементов создаются строки, в которых элементы повторяются столько раз, сколько они встречаются в списке. Например, если элемент "1" встречается три раза, в множество будет добавлена строка "111".
