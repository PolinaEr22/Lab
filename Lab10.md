# Тема 10. Декораторы и исключения
Отчет по Теме №10 выполнил(а):
- Еремеева Полина Алексеевна
- ИНО ЗБ ПОАС 22-1

| Задание | Сам_раб |
| ------ | ------ |
| Задание 1 |  + |
| Задание 2 | + |
| Задание 3 | + |
| Задание 4 | + |
| Задание 5 | + |

знак "+" - задание выполнено; знак "-" - задание не выполнено;

Работу проверили:
- к.э.н., доцент Панов М.А.

## Самостоятельная работа №1

##	Вовочка решил заняться спортивным программированием на python, но для этого он должен знать за какое время выполняется его программа. Он решил, что для этого ему идеально подойдет декоратор для функции, который будет выяснять за какое время выполняется та или иная функция. Помогите Вовочке в его начинаниях и напишите такой декоратор. 

```python
import time

# Декоратор для измерения времени выполнения функции
def calculate_time(func):
    def wrapper(*args, **kwargs):
        start_time = time.time()
        result = func(*args, **kwargs)
        end_time = time.time()
        print(f"Время выполнения функции {func.__name__}: {end_time - start_time} секунд")
        return result
    return wrapper

# Функция для вычисления чисел Фибоначчи
@calculate_time
def fibonacci():
    fib1 = fib2 = 1
    for i in range(2, 200):
        fib1, fib2 = fib2, fib1 + fib2
    print(fib2, end=' ')

if __name__ == '__main__':
    fibonacci()
```
### Результат.

![Меню](https://github.com/PolinaEr22/Lab/blob/Тема10/pic/1.png)

## Выводы

Данный код содержит следующие элементы:

1. Декоратор для измерения времени выполнения функции:
   - Этот декоратор calculate_time принимает функцию func в качестве параметра.
   - При вызове функции, декоратор будет измерять время, затраченное на выполнение функции func, и выводить результат в секундах.
   - Затем декоратор возвращает результат выполнения функции.

2. Функция для вычисления чисел Фибоначчи:
   - Функция fibonacci вычисляет первые 199 чисел Фибоначчи.
   - Она использует переменные fib1 и fib2, чтобы создать последовательность чисел Фибоначчи.
   - После вычисления чисел, они выводятся одно за другим с помощью print.

3. Проверка на 'main':
   - В данной программе выполняется проверка на то, является ли текущий файл главным исполняемым файлом (__main__). Если условие выполняется, то программа вызывает функцию fibonacci.

## Самостоятельная работа №2

## Посмотрев на Вовочку, вы также загорелись идеей спортивного программирования, начав тренировки вы узнали, что для решения некоторых задач необходимо считывать данные из файлов. Но через некоторое время вы столкнулись с проблемой что файлы бывают пустыми, и вы не получаете вводные данные для решения задачи. После этого вы решили не просто считывать данные из файла, а всю конструкцию оборачивать в исключения, чтобы избежать такой 
проблемы. Создайте пустой файл и файл, в котором есть какая-то информация. Напишите код программы. Если файл пустой, то, нужно вызвать исключение (“бросить исключение”) и вывести в консоль “файл пустой”, а если он не пустой, то вывести информацию из файла.


```python
try:
    with open('empty_file.txt', 'r') as file:
        data = file.read()
        if not data:
            raise Exception("Файл пустой")
        else:
            print(f"Информация из файла 'empty_file.txt': {data}")
except Exception as e:
    print(e)

print("------")

try:
    with open('data_file.txt', 'r') as file:
        data = file.read()
        if not data:
            raise Exception("Файл пустой")
        else:
            print(f"Информация из файла 'data_file.txt': {data}")
except Exception as e:
    print(e)
```
### Результат.

![Меню](https://github.com/PolinaEr22/Lab/blob/Тема10/pic/2.png)

## Выводы

 Данный код представляет собой обработку исключений в Python для работы с файлами. Давайте разберем, что означает каждая часть кода:

1. Обработка пустого файла 'emptyfile.txt'**:
   - Попытка открыть файл 'emptyfile.txt' для чтения.
   - Считывание содержимого файла в переменную data.
   - Если файл пустой (переменная data равна пустой строке), генерируется исключение Exception с сообщением "Файл пустой".
   - В противном случае (если файл не пустой), выводится информация из файла.

2. Обработка файла с данными 'datafile.txt'**:
   - Попытка открыть файл 'datafile.txt' для чтения.
   - Считывание содержимого файла в переменную data.
   - Если файл пустой, генерируется исключение Exception с сообщением "Файл пустой".
   - В противном случае (если файл не пустой), выводится информация из файла.

3. Исключения:
   - Если в блоке try возникает исключение (например, при попытке чтения пустого файла), код в блоке except выполняется. Перехваченное исключение сохраняется в переменной e, которая затем выводится с помощью print.

Таким образом, данный код позволяет обрабатывать ситуации, когда файл пустой, и выдает информацию из файла только в том случае, если файл содержит данные.

## Самостоятельная работа №3

## Напишите функцию, которая будет складывать 2 и введенное пользователем число, но если пользователь введет строку или другой неподходящий тип данных, то в консоль выведется ошибка “Неподходящий тип данных. Ожидалось число.”. Реализовать функционал программы необходимо через try/except и подобрать правильный тип исключения. 
```python
def add_two_numbers():
    try:
        num1 = 2
        num2 = int(input("Введите число: "))
        result = num1 + num2
        print(f"Результат сложения: {result}")
    except ValueError:
        print("Неподходящий тип данных. Ожидалось число.")

# Проведем тесты
add_two_numbers()
add_two_numbers()
```
### Результат.

![Меню](https://github.com/PolinaEr22/Lab/blob/Тема10/pic/3.png)

![Меню](https://github.com/PolinaEr22/Lab/blob/Тема10/pic/3.1.png)

## Выводы

В коде определена функция add_two_numbers(), которая пытается сложить число 2 с числом, введенным пользователем. Для обработки возможного исключения, когда пользователь вводит нечисловое значение, используется блок try/except.

Что означает каждая часть кода:

1. Функция add_two_numbers():
   - В блоке try присваивается значение num1 = 2.
   - Затем пытаемся преобразовать строку, введенную пользователем, в целое число и сохранить его в переменную num2.
   - Выполняем сложение num1 и num2 и сохраняем результат в переменную result.
   - Выводим результат сложения на экран, если ввод пользователя прошел успешно.

2. Обработка исключения ValueError:
   - Если при попытке преобразования введенного пользователем значения в целое число возникает исключение ValueError, то срабатывает блок except.
   - В этом случае выводится сообщение "Неподходящий тип данных. Ожидалось число." в консоль.

3. Проведение тестов:
   - Функция add_two_numbers() вызывается дважды для проведения тестов.
   - При вводе числа все работает как предполагается, результат сложения выводится на экран.
   - Если пользователь вводит нечисловое значение, срабатывает обработка исключения ValueError и выводится сообщение об ошибке.

В результате, код позволяет сложить число 2 с числом, введенным пользователем, и обрабатывает возможность некорректного ввода с выводом соответствующего сообщения.

## Самостоятельная работа №4

## Самостоятельно реализуйте наследование, продолжая работать с ранее созданным классом.

```python
# Создаем собственный декоратор
def my_decorator(func):
    def wrapper(*args, **kwargs):
        print("Декоратор добавляет дополнительное поведение перед выполнением функции")
        result = func(*args, **kwargs)
        print("Декоратор добавляет дополнительное поведение после выполнения функции")
        return result
    return wrapper

# Применяем декоратор к двум выдуманным функциям
@my_decorator
def greet(name):
    return f"Привет, {name}"

@my_decorator
def square(n):
    return n ** 2

# Вызываем и тестируем функции с декоратором
print(greet("Вася"))
print(square(5))
```
### Результат.

![Меню](https://github.com/PolinaEr22/Lab/blob/Тема10/pic/4.png)

## Выводы

В этом коде:
- my_decorator - это функция-декоратор, которая принимает другую функцию func в качестве аргумента. Внутри декоратора определяется обертка wrapper, которая добавляет вывод сообщений перед и после выполнения функции.
- Функции greet и square декорируются декоратором my_decorator, добавляя дополнительное поведение к этим функциям.
- При вызове декорированных функций greet и square, декоратор будет добавлять вывод сообщений до и после выполнения функций.

Таким образом, созданный декоратор добавляет дополнительное поведение к функциям, не изменяя их исходный код. В результате функции greet и square будут выполнены с дополнительным выводом из декоратора.

## Самостоятельная работа №5

## Создайте собственное исключение, которое будет использоваться в двух любых фрагментах кода. 

```python
# Создание собственного исключения CustomException
class CustomException(Exception):
    def __init__(self, message="Сработало наше собственное исключение!"):
        self.message = message
        super().__init__(self.message)

# Пример использования исключения в первом фрагменте кода
try:
    raise CustomException("Пример использования исключения в первом фрагменте кода")
except CustomException as e:
    print(f"Первый фрагмент кода: {e}")

# Пример использования исключения во втором фрагменте кода
def important_function(value):
    if value < 0:
        raise CustomException("Значение не может быть отрицательным")
    return value

try:
    result = important_function(-5)
    print(f"Второй фрагмент кода: Результат функции: {result}")
except CustomException as e:
    print(f"Второй фрагмент кода: {e}")
```
### Результат.

![Меню](https://github.com/PolinaEr22/Lab/blob/Тема10/pic/5.png)

## Выводы

Код состоит из следующих частей:

1. Создание исключения CustomException:
   - Создается новый класс CustomException, который наследуется от встроенного класса Exception.
   - В конструкторе класса устанавливается сообщение исключения.
   
2. Использование исключения в двух фрагментах кода:
   - В первом исключении генерируется исключение CustomException с пользовательским сообщением и обрабатывается.
   - Во втором фрагменте кода функция important_function проверяет значение и, если оно отрицательное, вызывает исключение CustomException.

При выполнении этого кода, мы увидим, как наше собственное исключение CustomException используется в двух различных ситуациях для обработки ошибок и вывода пользовательских сообщений.
